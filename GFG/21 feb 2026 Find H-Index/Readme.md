# Approach: Sorting and Reverse Iteration

This code calculates the H-Index, which is the maximum number $h$ such that a researcher has at least $h$ papers with $h$ or more citations.Here is how the logic flows:Sort the Array: The array is sorted in ascending order. This groups the lowest citations at the beginning and the highest at the end.Iterate Backwards (Descending Logic): By starting from the end of the array (n - 1) and moving down to 0, you are effectively looking at the papers with the highest citations first.Count Valid Papers: The variable papersCount (n - i) tracks how many papers you have looked at so far.Check the Condition: \* If the current paper's citation count (citations[i]) is greater than or equal to papersCount, it means you have found papersCount papers that have at least papersCount citations. You update h = papersCount.The Break Condition: If citations[i] is less than papersCount, it means the current paper does not have enough citations to push the H-Index higher. Because the array is sorted, all remaining papers to the left will have even fewer citations. Therefore, you can safely break the loop earlyâ€”the H-Index won't increase anymore.Complexity AnalysisTime Complexity: $\mathbf{O(N \log N)}$Sorting the citations array takes $$O(N \log N)$$ time, where $N$ is the number of elements in the array.The for loop iterates at most $N$ times, which takes $O(N)$ time.Since $O(N \log N)$ is the dominant term, it dictates the overall time complexity.Space Complexity: $\mathbf{O(\log N)}$ (or $\mathbf{O(1)}$ auxiliary)In Java, Arrays.sort() for primitive types (like int[]) uses a Dual-Pivot Quicksort. This algorithm operates in-place but requires $O(\log N)$ space on the call stack for recursion in the average and worst cases.Apart from the sorting algorithm's internal stack space, you are only using a few extra variables (n, h, i, papersCount), which take $O(1)$ constant space.
